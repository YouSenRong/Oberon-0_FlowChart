/* this is a oberon.cup */
/*
author: you
date: 2018/06/26
*/

/* ----------------------Preliminary Declarations Section--------------------*/
import java_cup.runtime.*;
import java.util.*;
import exceptions.*;
import callgraph.*;
import flowchart.*;
parser code
{:

	//public CallGraph graph;
	
	Module main_Module;
	Procedure procedure;
	Stack<WhileStatement> while_stack = new Stack();
	Stack<IfStatement>  if_stack = new Stack();
	/* a stack to store the current state of the statement 0:procedure, 1:while_statement, 2:if_statement */
	Stack<Integer> int_stack = new Stack();


:}

init with 
{:
	//graph = new CallGraph();
	main_Module = new Module("Oberon-0 FlowChart");
:}

scan with {: return getScanner().next_token(); :};
	


/* ------------Declaration of Terminals and Non Terminals Section----------- */
/* Terminals (tokens returned by the scanner).  */

   /* Terminals that have no value are listed first and then terminals
   that do have an value, in this case an integer value, are listed on
   the next line down. */

/* reserved word */
terminal String	MODULE, PROCEDURE, CONST, TYPE, VAR, RECORD, ARRAY, OF, WHILE, DO, IF, THEN, ELSIF, ELSE, BEGIN, END, INTEGER, BOOLEAN;

/* logic operator */
terminal String	OR, AND, NOT;

/* relation operator */
terminal String	EQUAL, UNEQUAL, LESS, LESS_EQUAL, GREAT, GREAT_EQUAL;

/* addictive operator */
terminal String	PLUS, MINUS;

/* multiplicative operator */
terminal String	TIMES, DIVIDE, MOD;

/* type operator */
terminal String	COLON;

/* selected_operator */
terminal String	DOT, LBRACKET, RBRACKET;

/* assign operator */
terminal String	ASSIGN;

/* seperated operator */
terminal String	COMMA, SEMICOLON;

/* paratheses */
terminal String	LPARENTHESES, RPARENTHESES;

/* identifier */
terminal String		IDENTIFIER;

/* number */
terminal String	NUMBER;

/* Non terminals used in the grammar section.  */

   /* Non terminals that have an object value are listed first and then
   non terminals that have an integer value are listed.  An object
   value means that it can be any type, it isn't set to a specific
   type.  So it could be an Integer or a String or whatever. */

non terminal String	program, module, module_begin;
non terminal String	statement_sequence, statement, assignment, procedure_call, if_statement, elsif_statement, else_statement, while_statement;
non terminal String	declarations, const_declaration, const_list, type_declaration, type_list, var_declaration, var_list, var_epsilon;
non terminal String	procedure_declaration, procedure_heading, procedure_body, procedure_begin;

non terminal String	formal_parameters, fp_section_list, fp_section, actual_parameters, expression_list;

non terminal String	expression, simple_expression, term, factor, expression_operator, simple_expression_operator, signed_operator, term_operator;

non terminal String	type, array_type, record_type;

non terminal String	field_lists, field_list, identifier_list;

non terminal String	selector;

/* -------------Precedence and Associatively of Terminals Section----------- */
precedence right	ASSIGN;
precedence left		OR, AND;
precedence right	NOT;
precedence left		EQUAL, UNEQUAL, LESS, LESS_EQUAL, GREAT, GREAT_EQUAL;
precedence left		PLUS, MINUS;
precedence left		TIMES, DIVIDE, MOD;
precedence left 	LPARENTHESES;


/* ----------------------------Grammar Section-------------------- */
/* The grammar for our parser. */


program ::= module:m
	{:
		System.out.println("Congratulation!!!");
		Procedure proc = main_Module.add("test_1");
		proc.add(new PrimitiveStatement("Yous_test_1"));
		main_Module.show();
	:};

module ::=	MODULE:m IDENTIFIER: identifier_1 SEMICOLON
			declarations
		module_begin
		END IDENTIFIER: identifier_2 DOT
		{:
		
		:};

module_begin ::=	BEGIN statement_sequence
			{:
			
			:}
			| /*epsilon*/
			{:
				RESULT = "";
			:};


declarations ::=	const_declaration: c_d
			type_declaration: t_d
			var_declaration: v_d
			procedure_declaration: p_d
			{:
				String str_declarations = "";
				if(c_d != null && c_d.length() > 0)
				{
					str_declarations = str_declarations + c_d + "<br>";
				}
				if(t_d != null && t_d.length() > 0)
				{
					str_declarations = str_declarations + t_d + "<br>";
				}
				if(v_d != null && v_d.length() > 0)
				{
					str_declarations = str_declarations + v_d + "<br>";
				}
				if(p_d != null && p_d.length() > 0)
				{
					str_declarations = str_declarations + p_d + "<br>";
				}
				// add the declarations to the flowchart
				procedure.add(new PrimitiveStatement(str_declarations));
			:};

const_declaration ::=	CONST:c const_list: c_l
			{:
				RESULT = c + " " + c_l;
			:} 
			| /*epsilon*/
			{:
				RESULT = "";
			:};

const_list ::=		const_list: c_l IDENTIFIER:identifier EQUAL: equal expression: e SEMICOLON: semicolon
			{:
				RESULT = c_l + " " + identifier + " " + equal + " " + e + " " + semicolon;
			:}
			| /*empty*/
			{:
				RESULT = "";
			:};

type_declaration ::=	TYPE:t type_list : t_l
			{:
				RESULT = t + " " + t_l;
			:}
			| /*eplison*/
			{:
				RESULT = "";
			:};

type_list ::=		type_list:t_l IDENTIFIER:identifier EQUAL: equal type: t SEMICOLON: semicolon
			{:
				RESULT = t_l + " " + identifier + " " + equal + " " + t + " " + semicolon;
			:}
			| /*eplison*/
			{:
				RESULT = "";
			:};

var_declaration ::=	VAR:var var_list: v_l
			{:
				RESULT = var + " " + v_l;
			:}
			| /*empty*/
			{:
				RESULT = "";
			:};

var_list ::=		var_list: v_l identifier_list: id_list COLON: colon type: t SEMICOLON: semicolon
			{:
				RESULT = v_l + " " + id_list + " " + colon + " " + t + " " + semicolon;
			:}
			| /*epsilon*/
			{:
				RESULT = "";
			:};

identifier_list ::=	identifier_list: id_list COMMA: comma IDENTIFIER: identifier
			{:
				RESULT = id_list + " " + comma + " " + identifier;
			:}
			| IDENTIFIER: identifier
			{:
				RESULT = identifier;
			:};

procedure_declaration ::=	procedure_declaration procedure_heading SEMICOLON 
				procedure_body SEMICOLON
				| /*epsilon*/
				{:
					RESULT = "";
				:};

procedure_heading ::=	PROCEDURE IDENTIFIER: identifier formal_parameters: fp
			{:
				int_stack.push(new Integer(0));
				procedure = main_Module.add(identifier);
			:};

formal_parameters ::=	LPARENTHESES fp_section_list: fp_s_l RPARENTHESES
			{:
				RESULT = "(" + fp_s_l + ")";
			:}
			| LPARENTHESES RPARENTHESES
			{:
				RESULT = "(" + ")";
			:}
			| /*epsilon*/
			{:
				RESULT = "";
			:};

fp_section_list ::=	fp_section_list: fp_s_l SEMICOLON: semicolon fp_section: fp_s
			{:
				RESULT = fp_s_l + semicolon + fp_s;
			:}
			| fp_section: fp_s
			{:
				RESULT = fp_s;
			:};

fp_section ::=		var_epsilon: v_e identifier_list: id_list COLON: colon type: t
			{:
				RESULT = v_e + id_list + colon + t;
			:};

var_epsilon ::=		VAR:var
			{:
				RESULT = var; 
			:}
			| /*eplison*/
			{:
				RESULT = "";
			:};

type ::=		IDENTIFIER: identifier
			{:
				RESULT = identifier ;	
			:}
			| INTEGER: i
			{:
				RESULT = i;
			:}
			| BOOLEAN: b
			{:
				RESULT = b;
			:}
			| array_type: a_t
			{:
				RESULT = a_t;
			:}
			| record_type: r_t
			{:
				RESULT = r_t;
			:};
array_type ::=		ARRAY: array expression OF type
			{:
				RESULT = array;
			:};

record_type ::=		RECORD: record
				field_lists
			END
			{:
				RESULT = record;
			:};

field_lists ::=		field_lists: f_ls SEMICOLON: semicolon field_list: f_l
			{:
				RESULT = f_ls + semicolon + f_l;
			:}
			| field_list: f_l
			{:
				RESULT = f_l;
			:};

field_list ::=		identifier_list: id_list COLON: colon type: t
			{:
				RESULT = id_list + colon + t;
			:}
			| /*epsilon*/
			{:
				RESULT = "";
			:};

procedure_body ::=	declarations procedure_begin END IDENTIFIER: identifier
			{:
				int_stack.pop();
			:};

procedure_begin ::=	BEGIN statement_sequence 
			| /*empty*/
			{:
				RESULT = "";
			:};

				
statement_sequence ::=	statement_sequence: s_s SEMICOLON: semicolon statement: s
			{:
				RESULT = s_s + semicolon + s;
			:}
			| statement: s
			{:
				RESULT = s;
			:};

statement ::=		assignment: a
			{:
				if(!int_stack.empty())
				{
					if(int_stack.peek() == 0)
					{
						procedure.add(new PrimitiveStatement(a));
					}
					else if(int_stack.peek() == 1 )
					{
						while_stack.peek().getLoopBody().add(new PrimitiveStatement(a));
					}
					else if(int_stack.peek() == 2 )
					{	
						if_stack.peek().getTrueBody().add(new PrimitiveStatement(a));
					}
					else
					{	
						if_stack.peek().getFalseBody().add(new PrimitiveStatement(a));
					}
				}

				
			:}
			| procedure_call: p_c
			{:
				if(!int_stack.empty())
				{
					if(int_stack.peek() == 0)
					{
						procedure.add(new PrimitiveStatement(p_c));
					}
					else if(int_stack.peek() == 1 )
					{
						while_stack.peek().getLoopBody().add(new PrimitiveStatement(p_c));
					}
					else if(int_stack.peek() == 2 )
					{	
						if_stack.peek().getTrueBody().add(new PrimitiveStatement(p_c));
					}
					else
					{	
						if_stack.peek().getFalseBody().add(new PrimitiveStatement(p_c));
					}
				}
			:}
			| if_statement
			| while_statement
			| /*epsilon*/
			{:
				RESULT = "";
			:};

while_statement ::=	WHILE expression: e DO
			{:	
				procedure.add(new PrimitiveStatement("WHILE Statement"));
				WhileStatement wstmt = new WhileStatement(e);
				if(!int_stack.empty())
				{
					if(int_stack.peek() == 0)
					{
						procedure.add(wstmt);
					}
					else if(int_stack.peek() == 1 )
					{
						while_stack.peek().getLoopBody().add(wstmt);
					}
					else if(int_stack.peek() == 2 )
					{	
						if_stack.peek().getTrueBody().add(wstmt);
					}
					else
					{	
						if_stack.peek().getFalseBody().add(wstmt);
					}
				}
				int_stack.push(new Integer(1));
				while_stack.push(wstmt);
			:}
				statement_sequence
			END
			{:
				int_stack.pop();
				while_stack.pop();
				procedure.add(new PrimitiveStatement("WHILE Statement END"));
			:};

if_statement ::=	IF expression: e THEN 
			{:
				IfStatement ifstmt = new IfStatement(e);
				if(!int_stack.empty())
				{
					if(int_stack.peek() == 0)
					{
						procedure.add(ifstmt);
					}
					else if(int_stack.peek() == 1 )
					{
						while_stack.peek().getLoopBody().add(ifstmt);
					}
					else if(int_stack.peek() == 2 )
					{	
						if_stack.peek().getTrueBody().add(ifstmt);
					}
					else
					{	
						if_stack.peek().getFalseBody().add(ifstmt);
					}
				}
				int_stack.push(new Integer(2));
				if_stack.push(ifstmt);
			:}
				statement_sequence
			elsif_statement
			else_statement
			END
			{:
				int_stack.pop();
				procedure.add(new PrimitiveStatement("IF Statement"));
			:};

elsif_statement ::=	elsif_statement
			ELSIF:elsif expression:e THEN
			{:
				IfStatement ifstmt = new IfStatement(e);
				if(!int_stack.empty())
				{
					if(int_stack.peek() == 0)
					{
						procedure.add(ifstmt);
					}
					else if(int_stack.peek() == 1 )
					{
						while_stack.peek().getLoopBody().add(ifstmt);
					}
					else if(int_stack.peek() == 2 )
					{	
						if_stack.peek().getTrueBody().add(ifstmt);
					}
					else
					{	
						if_stack.peek().getFalseBody.add(ifstmt);
					}
				}
				int_stack.push(new Integer(2));
				if_stack.push(ifstmt);
			:}
				statement_sequence
			{:
				if_stack.pop();
				int_stack.pop();
			:}
			| /*epsilon*/
			{:
				RESULT = "";
			:};

else_statement ::=	ELSE:e 
			{:
				int_stack.push(new Integer(3));
			:}
				statement_sequence: s_s
			{:
				int_stack.pop();
			:}
			| /*epsilon*/
			{:
				RESULT = "";
			:};

procedure_call ::=	IDENTIFIER: identifier actual_parameters: a_p
			{:
				RESULT = identifier + a_p;
			:};
			
actual_parameters ::=	LPARENTHESES:lp expression_list:ex_l RPARENTHESES: rp
			{:
				RESULT = lp + ex_l + rp;
			:}
			| LPARENTHESES:lp RPARENTHESES:rp
			{:
				RESULT = "(" + ")";
			:}
			| /*epsilon*/
			{:
				RESULT = "";
			:};

expression_list ::=	expression_list: ex_l COMMA: comma expression: e
			{:
				RESULT = ex_l + comma + e;	
			:}
			| expression: e
			{:
				RESULT = e;
			:};

assignment ::=		IDENTIFIER:identifier selector: s ASSIGN: assign expression: e
			{:
				RESULT = identifier + s + assign + e;
			:};

expression ::=		simple_expression: s_e_1 expression_operator: e_o simple_expression: s_e_2
			{:
				RESULT = s_e_1  + e_o  + s_e_2 ;
				/*System.out.println(RESULT);*/
			:}
			| simple_expression: s_e
			{:
				RESULT = s_e ;
				/*System.out.println(RESULT);*/
			:}
			| expression_operator simple_expression
			{:
				if (true) throw new MissingOperandException();
			:}
			| simple_expression expression_operator
			{:
				if (true) throw new MissingOperandException();
			:};

expression_operator ::=	EQUAL: equal 
			{:
				RESULT = equal ;
				/*System.out.println(RESULT);*/
			:}
			| UNEQUAL: unequal
			{:
				RESULT = unequal ;
				/*System.out.println(RESULT);*/
			:} 
			| LESS: less
			{:
				RESULT = less ;
				/*System.out.println(RESULT);*/
			:}
			| LESS_EQUAL: less_equal
			{:
				RESULT = less_equal ;
				/*System.out.println(RESULT);*/
			:}
			| GREAT: great
			{:
				RESULT = great ;
				/*System.out.println(RESULT);*/
			:}
			| GREAT_EQUAL:great_less
			{:
				RESULT = great_less ;
				/*System.out.println(RESULT);*/
			:};

simple_expression ::=	simple_expression: s_e simple_expression_operator: s_e_o term: t
			{:
				RESULT = s_e  + s_e_o  + t ;
				/*System.out.println(RESULT);*/
			:}
			| signed_operator: s_o term: t
			{:
				RESULT = s_o  + t ;
			:}
			| OR term
			{:
				if(true) throw new MissingOperandException();
			:};
			
signed_operator ::=	PLUS: plus
			{:
				RESULT = plus ;
				/*System.out.println(RESULT);*/
				
			:}
			| MINUS: minus
			{:
				RESULT = minus ;
				/*System.out.println(RESULT);*/
			:}
			| /*epsilon*/
			{:
				RESULT = "";
			:};

simple_expression_operator ::=	PLUS: plus
				{:
					RESULT = plus ;
					/*System.out.println(RESULT);*/
				
				:}	
				| MINUS: minus
				{:
					RESULT = minus ;
					/*System.out.println(RESULT);*/
				:}
				| OR: or
				{:
					/*RESULT = or ;*/
					/*System.out.println(RESULT);*/
				:};

term ::=		term: t term_operator: t_o factor: f
			{:
				RESULT = t  + t_o  + f ;
				/*System.out.println(RESULT);*/
			:}
			| factor: f
			{:
				RESULT = f ;
				/*System.out.println(RESULT);*/
			:}
			| term_operator factor
			{:
				if(true) throw new MissingOperandException(); 
			:}
			| term factor
			{:
				if(true) throw new MissingOperatorException();
			:};

term_operator ::=	TIMES: times
			{:
				RESULT = times ;
				/*System.out.println(RESULT);*/
			:}
			| DIVIDE: divides
			{:
				RESULT = divides ;
				/*System.out.println(RESULT);*/
			:}
			| MOD: mod
			{:
				RESULT = mod ;
				/*System.out.println(RESULT);*/
			:}
			| AND: and
			{:
				RESULT = and ;
				/*System.out.println(RESULT);*/
			:};

factor ::=		IDENTIFIER: identifier selector: s
			{:
				RESULT = identifier  + s ;
				/*System.out.println(RESULT);*/
			:}
			| NUMBER: number
			{:
				RESULT = number ;
				/*System.out.println(RESULT);*/
			:}
			| LPARENTHESES: lparen expression: e RPARENTHESES: rparen
			{:
				RESULT = lparen  + e  + rparen ;
				/*System.out.println(RESULT);*/
			:}
			| NOT: not factor: f
			{:
				RESULT = not  + f ;
				/*System.out.println(RESULT);*/
			:};


selector ::=		selector: s DOT: dot IDENTIFIER: identifier
			{:
				RESULT = s  + dot  + identifier ;
				/*System.out.println(RESULT);*/
			:}
			| selector:s LBRACKET: lbracket expression: e RBRACKET: rbracket
			{:
				RESULT = s + lbracket + e + rbracket ;
				/*System.out.println(RESULT);*/
			:}
			| /*epsilon*/
			{:
				RESULT = "";
				/*System.out.println(RESULT);*/
			:};

